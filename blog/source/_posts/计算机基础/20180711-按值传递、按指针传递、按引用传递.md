#### 变量传递类型

* 值传递：
  * 普通值传递
  * 指针值传递


* 引用传递：(只要c++有，c、java都没有)

```c
#include <iostream>

void f(int c) {
    printf("c :%d\n", c);
    printf("c的地址:%p\n", &c);
    c = 100;
}

void f2(int &c) {
    printf("c :%d\n", c);
    printf("c的地址:%p\n", &c);
    c = 100;
}

void f3(int *c) {
    printf("c :%x\n", c);
    printf("*c:%d\n", *c);
    printf("c的地址:%p\n", &c);
    printf("*c的地址:%p\n",&(*c));
    *c = 100;
}

int main() {
    int a = 5;
    printf("a的地址：%p\n", &a);

//    int b = 10;
//    printf("b的地址：%p\n", &b);
//
//    b = a;
//    printf("b的地址：%p\n", &b);

//    int *p = &a;
//    printf("p：%p\n", p);
//
//    printf("p的地址：%p\n", &p);

    // 按值传递
    // f(a);
    // 按引用传递
    // f2(a);
    // 按指针传递（按地址传递）
    f3(&a);

    printf("a：%d\n", a);

    printf("a的地址：%p\n", &a);

    return 0;
}

```
* 值传递
  形参是实参的拷贝（会在栈内存中创建形参并拷贝实参的值），函数执行完毕后会自动清除栈内存。所以从被调用函数的角度来说，值传递是单向的，形参不能改变实参。当内部函数不需要改变实参则采用值传递。

* 指针传递
 指针传递参数的本质是值传递，只不过它传递的是一个地址值，函数执行的时候在栈中创建并拷贝实参的地址值。函数可以根据地址，找到地址指向的内存单元。因而可以改变主函数实参指向的变量的值。
 如果要数据对象是数组，则只能使用指针。因为值传递不能直接数组，引用的对象也不能是数组。

* 引用传递
  &表示引用实参，即代表形参是实参的一个别名。操作引用变量就是操作实参变量。这是C++语法写法，标准C是不支持这种写法的。
    在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

* 引用和指针的区别：
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用初始化后不能改变指向（引用必须在创建的时候初始化）。使用时，引用更加安全，指针更加灵活。但是就效率和占用内存的来说，指针和应用是差不多的。