### 一、出现RST包的情况

1、连接请求到达时，目的端口不存在情况

2、向一个已经关闭的连接发送数据

3、向一个已经崩溃的对端发送数据（连接之前已经被建立）

4、请求超时。 使用setsockopt的SO_RCVTIMEO选项设置recv的超时时间。接收数据超时时，会发送RST包

5、close(sockfd)时，直接丢弃接收缓冲区未读取的数据，并给对方发一个RST。这个是由SO_LINGER选项来控制的

6、TCP收到了一个根本不存在的连接上的分节

7、处理半打开连接，  一方关闭了连接，另一方却没有收到结束报文（如网络故障），此时另一方还维持着原来的连接。而一方即使重启，也没有该连接的任何信息。这种状态 就叫做半打开连接。而此时另一方往处于半打开状态的连接写数据，则对方回应RST复位报文

8、应用层可以通过 设置SO_LINGER 来发送RST

```c
#include <sys/socket.h>
struct linger {
int l_onoff //0=off, nonzero=on(开关)
int l_linger //linger time(延迟时间)
}
```

### 二、收到RST包后的表现

1、TCP socket在任何状态下，只要收到RST包，即可进入CLOSED初始状态

2、值得注意的是RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接

### 三、程序中表现

1、阻塞模型下，内核无法主动通知应用层出错，只有应用层主动调用read()或者write()这样的IO系统调用时，内核才会利用出错来通知应用层对端RST

2、非阻塞模型下，select或者epoll会返回sockfd可读,应用层对其进行读取时，read()会报错RST **这点很重要，这也是大多数Connection reset by peer的原因，我们需要捕获这个异常并关闭连接**
